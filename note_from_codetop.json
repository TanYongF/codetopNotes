[
    {
        "leetcode": 115,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    void down(vector<int>& nums, int l, int r){\n        int father = l, son = (father << 1) + 1;\n        while(son <= r){\n            if(son + 1 <= r and nums[son + 1] >= nums[son]) son++;\n            if(nums[father] >= nums[son]) return;\n            else swap(nums[father], nums[son]);\n            father = son;\n            son = (father << 1) + 1;\n        }\n    }\n    void heapfity(vector<int>& nums, int l, int r){\n        for(int i = (r >> 1) - 1; i >= l; i--){\n            down(nums, i, r - 1);\n        }\n    }\n    vector<int> inventoryManagement(vector<int>& nums, int cnt) {\n        int m = nums.size();\n        // build heap from first-cnt items \n        heapfity(nums, 0, cnt);\n\n        for(int i = cnt; i < m ; i++){\n            if(nums[i] >= nums[0]) continue;\n            swap(nums[i], nums[0]);\n            down(nums, 0, cnt - 1);\n        }\n        return vector<int>(nums.begin(), nums.begin() + cnt);\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 115,
            "frontend_question_id": "剑指 Offer 40",
            "question_id": 100301,
            "title": "最小的k个数",
            "content": "<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,1], k = 2\n<strong>输出：</strong>[1,2] 或者 [2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [0,1,2,1], k = 1\n<strong>输出：</strong>[0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>\n\t<li><code>0 &lt;= arr[i]&nbsp;&lt;= 10000</code></li>\n</ul>\n",
            "level": 1,
            "slug_title": "zui-xiao-de-kge-shu-lcof",
            "expand": false
        }
    },
    {
        "leetcode": 730,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isCompleteTree(TreeNode* root) {\n      queue<TreeNode*> q;\n      bool flag = false;\n      q.push(root);\n      while(not q.empty()){\n        TreeNode* cur = q.front();\n        q.pop();\n        if(cur == nullptr){\n          flag = true;\n          continue;\n        }\n        if(flag) return false;\n        q.push(cur->left);\n        q.push(cur->right); \n      }\n      return true;\n      \n\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 730,
            "frontend_question_id": "958",
            "question_id": 998,
            "title": "二叉树的完全性检验",
            "content": "<p>给定一个二叉树，确定它是否是一个<em>完全二叉树</em>。</p>\n\n<p><strong><a href=\"https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin\" target=\"_blank\">百度百科</a>中对完全二叉树的定义如下：</strong></p>\n\n<p>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~&nbsp;2<sup>h</sup>&nbsp;个节点。）</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png\" style=\"height: 145px; width: 180px;\"></p>\n\n<pre><strong>输入：</strong>[1,2,3,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png\"></strong></p>\n\n<pre><strong>输入：</strong>[1,2,3,4,5,null,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>值为 7 的结点没有尽可能靠向左侧。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>树中将会有 1 到 100 个结点。</li>\n</ol>\n",
            "level": 2,
            "slug_title": "check-completeness-of-a-binary-tree",
            "expand": false
        }
    },
    {
        "leetcode": 776,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\n//堆排序\nclass Solution {\npublic:\n    void down(vector<int>& nums, int left, int right){\n        int father = left, son = (father << 1) + 1;\n        while(son <= right){\n            if(son + 1 <= right and nums[son] <= nums[son + 1]) son++;\n            if(nums[father] >= nums[son]) return;\n            swap(nums[father], nums[son]);\n            father = son;\n            son = (father << 1) + 1;\n        }\n        \n    }\n    void heapfiy(vector<int> &nums){\n        int n = nums.size();\n        for(int i = (n >> 1) - 1; i >= 0; i--){\n            down(nums, i, n - 1);\n        }\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        heapfiy(nums);\n        int n = nums.size();\n        for(int i = n - 1; i >= 1; i--){\n            swap(nums[i], nums[0]);\n            down(nums, 0, i - 1);\n        }\n        return nums; \n    }\n};\n```",
        "leetcodeInfo": {
            "id": 776,
            "frontend_question_id": "912",
            "question_id": 948,
            "title": "排序数组",
            "content": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你将该数组升序排列。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,2,3,1]\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,1,1,2,0,0]\n<strong>输出：</strong>[0,0,1,1,2,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\n\t<li><code>-50000 &lt;= nums[i] &lt;= 50000</code></li>\n</ol>\n",
            "level": 2,
            "slug_title": "sort-an-array",
            "expand": false
        }
    },
    {
        "leetcode": 801,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n\n    unordered_map<int,int> mp;\n    int dp(int k, int n){\n        if(k == 1) return n;\n        if(n == 0) return 0;\n        if(mp.count(n*100 + k)) return mp[100 * n + k];\n        int ans = INT_MAX;\n        int left = 1, right = n;\n        while(left <= right){\n            int mid = (left + right) >> 1;\n            int low = dp(k-1, mid - 1);\n            int high  = dp(k, n - mid);\n\n            ans = min(ans, max(low, high) + 1);\n            if(low <= high){\n                left = mid + 1;\n            }else right = mid - 1;\n        }\n        mp[100 * n + k] = ans;\n        return ans;\n    }\n    int superEggDrop(int k, int n) {\n        return dp(k, n);\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 801,
            "frontend_question_id": "887",
            "question_id": 923,
            "title": "鸡蛋掉落",
            "content": "<p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足 <code>0 <= f <= n</code> ，任何从<strong> 高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>\n\n<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 <= x <= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 \n否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 \n如果它没碎，那么肯定能得出 f = 2 。 \n因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, n = 6\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, n = 14\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= 100</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "super-egg-drop",
            "expand": false
        }
    },
    {
        "leetcode": 821,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\n// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    int rand10() {\n        while(true){\n            int i = rand7();\n            int j = rand7();\n            int idx = (i-1) * 7 + j;\n            if(idx <= 40) return idx % 10 + 1;\n            else continue; \n        }\n        return -1;\n\n        \n        \n    }\n};\n```",
        "leetcodeInfo": {
            "id": 821,
            "frontend_question_id": "470",
            "question_id": 903,
            "title": "用 Rand7() 实现 Rand10()",
            "content": "<p>已有方法&nbsp;<code>rand7</code>&nbsp;可生成 1 到 7 范围内的均匀随机整数，试写一个方法&nbsp;<code>rand10</code>&nbsp;生成 1 到 10 范围内的均匀随机整数。</p>\n\n<p>不要使用系统的&nbsp;<code>Math.random()</code>&nbsp;方法。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>1\n<strong>输出: </strong>[7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>2\n<strong>输出: </strong>[8,4]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>3\n<strong>输出: </strong>[8,1,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li><code>rand7</code>&nbsp;已定义。</li>\n\t<li>传入参数:&nbsp;<code>n</code>&nbsp;表示&nbsp;<code>rand10</code>&nbsp;的调用次数。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong></p>\n\n<ol>\n\t<li><code>rand7()</code>调用次数的&nbsp;<a href=\"https://en.wikipedia.org/wiki/Expected_value\" target=\"_blank\">期望值</a>&nbsp;是多少&nbsp;?</li>\n\t<li>你能否尽量少调用 <code>rand7()</code> ?</li>\n</ol>\n",
            "level": 2,
            "slug_title": "implement-rand10-using-rand7",
            "expand": false
        }
    },
    {
        "leetcode": 832,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int shortestSubarray(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<long> preSumArr(n + 1, 0);\n        for(int i = 0; i < n; i++) preSumArr[i + 1] = nums[i] + preSumArr[i];\n        int res = n + 1;\n        deque<int> qu;\n        for(int i = 0; i <= n; i++){\n            long curSum = preSumArr[i];\n            // j ____ i  如果这一段可以构成，那么之后j不可能再作为边界\n            while(not qu.empty() and preSumArr[i] - preSumArr[qu.front()] >= k){\n                res = min(res, i - qu.front());\n                qu.pop_front();\n            }\n            // j i 如果pre[i] < pre[j], 那么j可以作为左边界，那么i肯定可以呀，所以 j一定没用有了。 \n            while(not qu.empty() and curSum <= preSumArr[qu.back()]) qu.pop_back();\n            qu.push_back(i);\n        }\n        return res < n + 1 ? res : -1;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 832,
            "frontend_question_id": "862",
            "question_id": 892,
            "title": "和至少为 K 的最短子数组",
            "content": "<p>返回 <code>A</code> 的最短的非空连续子数组的<strong>长度</strong>，该子数组的和至少为 <code>K</code> 。</p>\n\n<p>如果没有和至少为&nbsp;<code>K</code>&nbsp;的非空子数组，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>A = [1], K = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>A = [1,2], K = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>A = [2,-1,2], K = 3\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 50000</code></li>\n\t<li><code>-10 ^ 5&nbsp;&lt;= A[i] &lt;= 10 ^ 5</code></li>\n\t<li><code>1 &lt;= K &lt;= 10 ^ 9</code></li>\n</ol>\n",
            "level": 3,
            "slug_title": "shortest-subarray-with-sum-at-least-k",
            "expand": false
        }
    },
    {
        "leetcode": 1011,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//dfs\nclass Solution {\npublic:\n    int m, n, ans = 0, num = 0;\n    int x[4] = {1, 0, -1, 0}, y[4] = {0, 1, 0, -1};   \n     \n    int dfs(int px, int py, vector<vector<int>> &grid){\n      if(px < 0 or px >= m or py < 0 or py >= n or not grid[px][py]) return 0;\n      num++;\n      grid[px][py] = 0;\n      for(int i = 0; i < 4; i++){\n        dfs(px + x[i], py + y[i], grid);\n      }\n      return num;\n    }\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n      m = grid.size(), n = grid[0].size();\n      for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n          if(grid[i][j]) {\n            num = 0;\n            ans = max(dfs(i, j, grid), ans); \n          }\n        }\n      }\n      return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1011,
            "frontend_question_id": "695",
            "question_id": 695,
            "title": "岛屿的最大面积",
            "content": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>\n\n<p><strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>\n\n<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>\n\n<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直这四个方向上的 <code>1</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,0,0,0,0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "max-area-of-island",
            "expand": false
        }
    },
    {
        "leetcode": 1014,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n      \n        unordered_map<string,int> cnt;\n        for(auto word : words){\n            cnt[word]++;\n        }\n        auto cmp = [](const pair<string, int> &a, const pair<string, int> &b){\n            return a.second == b.second ? a.first < b.first : a.second > b.second;\n        };\n        priority_queue<pair<string,int>, vector<pair<string,int>>, decltype(cmp)> pq;\n        // cout << cnt.size();\n        for(auto &it : cnt){\n            pq.push(it);\n            if(pq.size() > k){\n                pq.pop();\n            }\n        }\n        cout << pq.size() <<endl;\n        vector<string> ret;\n        while(not pq.empty()){\n            auto it = pq.top(); pq.pop();\n            ret.push_back(it.first);\n        }\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1014,
            "frontend_question_id": "692",
            "question_id": 692,
            "title": "前K个高频单词",
            "content": "<p>给一非空的单词列表，返回前&nbsp;<em>k&nbsp;</em>个出现次数最多的单词。</p>\n\n<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2\n<strong>输出:</strong> [&quot;i&quot;, &quot;love&quot;]\n<strong>解析:</strong> &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。\n    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4\n<strong>输出:</strong> [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]\n<strong>解析:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，\n    出现次数依次为 4, 3, 2 和 1 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ol>\n\t<li>假定 <em>k</em> 总为有效值， 1 &le; <em>k</em> &le; 集合元素数。</li>\n\t<li>输入的单词均由小写字母组成。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>扩展练习：</strong></p>\n\n<ol>\n\t<li>尝试以&nbsp;<em>O</em>(<em>n</em> log <em>k</em>) 时间复杂度和&nbsp;<em>O</em>(<em>n</em>) 空间复杂度解决。</li>\n</ol>\n",
            "level": 2,
            "slug_title": "top-k-frequent-words",
            "expand": false
        }
    },
    {
        "leetcode": 1172,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        int m = nums.size();\n        int ans = INT_MIN, cur = 0;\n        mp[0] = -1;\n        for(int i = 0; i < m; i++){\n            cur += (nums[i] == 0 ? -1 : 1);\n            if(mp.count(cur)){\n                ans = max(ans, i - mp[cur]);\n            } else{\n                mp[cur] = i;\n            }\n        }\n        return ans == INT_MIN ? 0 : ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1172,
            "frontend_question_id": "525",
            "question_id": 525,
            "title": "连续数组",
            "content": "<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1,0]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "contiguous-array",
            "expand": false
        }
    },
    {
        "leetcode": 1191,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int m = nums.size();\n        vector<int> ans(m, -1);\n        stack<int> st;\n        for(int i = 0; i < m; i++){\n            while(not st.empty() and nums[st.top()] < nums[i]){\n                ans[st.top()] = nums[i];\n                st.pop();\n            }\n            st.push(i);\n        }\n        for(int i = 0; i < m; i++){\n            while(not st.empty() and nums[st.top()] < nums[i]){\n                ans[st.top()] = nums[i];\n                st.pop();\n            }\n            st.push(i);\n        }\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1191,
            "frontend_question_id": "503",
            "question_id": 503,
            "title": "下一个更大元素 II",
            "content": "<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,2,1]\n<strong>输出:</strong> [2,-1,2]\n<strong>解释:</strong> 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n</pre>\n\n<p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p>\n",
            "level": 2,
            "slug_title": "next-greater-element-ii",
            "expand": false
        }
    },
    {
        "leetcode": 1222,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n\n    int m;\n    vector<string> split(const string &s, char ch){\n        int i = 0, j = 0, m = s.size();\n        vector<string> ret;\n        while(j < m){\n            while(i < m and s[i] == ch) i++;\n            j = i;\n            while(j < m and s[j] != ch) j++;\n            if(i < m) ret.push_back(s.substr(i, j - i));\n            i = j;\n        }\n        return ret;\n    }\n    bool isIPv4(string s){\n        vector<string> nums = split(s, '.');\n        if(nums.size() != 4) return false;\n        int numberLen = 0;\n        for(auto &num : nums){\n            numberLen += num.size();\n            if(num.size() > 1 and num[0] == '0')return false;\n            for(auto &ch : num)  if(ch < '0' or ch > '9') return false;\n            if(num.size() > 3 or stoi(num) > 255) return false;\n        }\n        if((int)s.size() - numberLen != 3) return false;\n        return true;\n    }\n\n    bool isIPv6(string s){\n        vector<string> nums = split(s, ':');\n        if(nums.size() != 8) return false;\n        int numberLen = 0;\n        for(auto &num : nums){\n            numberLen += num.size();\n            if(num.size() > 4) return false;\n            for(auto &ch : num){\n                if((ch <= '9' and ch >= '0') or (ch <= 'f' and ch >= 'a') or (ch <= 'F' and ch >= 'A')) continue;\n                else return false;\n            }  \n        }\n        if((int)s.size() - numberLen > 7) return false;\n        return true;  \n    }\n    string validIPAddress(string queryIP) {\n        if(isIPv4(queryIP)) return \"IPv4\";\n        else if(isIPv6(queryIP)) return \"IPv6\";\n        else return \"Neither\";   \n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1222,
            "frontend_question_id": "468",
            "question_id": 468,
            "title": "验证IP地址",
            "content": "<p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或&nbsp;IPv6 地址。</p>\n\n<ul>\n\t<li>如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；</li>\n\t<li>如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；</li>\n\t<li>如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> 。</li>\n</ul>\n\n<p><strong>IPv4</strong>&nbsp;地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为&nbsp;0 -&nbsp;255，&nbsp;用(&quot;.&quot;)分割。比如，<code>172.16.254.1</code>；</p>\n\n<p>同时，IPv4 地址内的数不会以 0 开头。比如，地址&nbsp;<code>172.16.254.01</code> 是不合法的。</p>\n\n<p><strong>IPv6</strong>&nbsp;地址由 8 组 16 进制的数字来表示，每组表示&nbsp;16 比特。这些组数字通过 (&quot;:&quot;)分割。比如,&nbsp;&nbsp;<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以，&nbsp;<code>2001:db8:85a3:0:0:8A2E:0370:7334</code> 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。</p>\n\n<p>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。&nbsp;比如，&nbsp;<code>2001:0db8:85a3::8A2E:0370:7334</code> 是无效的 IPv6 地址。</p>\n\n<p>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如，&nbsp;<code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> 是无效的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;172.16.254.1&quot;\n<strong>输出：</strong>&quot;IPv4&quot;\n<strong>解释：</strong>有效的 IPv4 地址，返回 &quot;IPv4&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;\n<strong>输出：</strong>&quot;IPv6&quot;\n<strong>解释：</strong>有效的 IPv6 地址，返回 &quot;IPv6&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;256.256.256.256&quot;\n<strong>输出：</strong>&quot;Neither&quot;\n<strong>解释：</strong>既不是 IPv4 地址，又不是 IPv6 地址\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;\n<strong>输出：</strong>&quot;Neither&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>IP = &quot;1e1.4.5.6&quot;\n<strong>输出：</strong>&quot;Neither&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>IP</code> 仅由英文字母，数字，字符 <code>&#39;.&#39;</code> 和 <code>&#39;:&#39;</code> 组成。</li>\n</ul>\n",
            "level": 2,
            "slug_title": "validate-ip-address",
            "expand": false
        }
    },
    {
        "leetcode": 1290,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    string ans;\n    string decodeString(string s) {\n        int n = s.size();\n        if(s.size() == 0) return \"\";\n        string temp;\n        // cout << s << endl;\n        // int times = 0;\n        for(int i = 0; i < n; i++){\n            if(s[i] <= 'z' and s[i] >= 'a') temp.push_back(s[i]);\n            if(s[i] >= '0' and s[i] <= '9'){\n                int times = 0;\n                while(s[i] >= '0' and s[i] <= '9') times = times * 10 + s[i++] - '0';\n                // cout << times << endl;\n                int start = i + 1, end;\n                i++; // start from '[' index\n                int left = 1;\n                while(left){\n                    if(s[i] == ']') left--;\n                    else if(s[i] == '[') left++;\n                    i++;\n                }\n                end = i - 2;\n                string in = decodeString(s.substr(start, end - start + 1));\n                for(int k = 0; k < times; k++) temp += in;\n                i--; // back to ']' index\n            }\n        }\n        return temp;\n    }\n};\n```\n\n\n## 栈方法解决\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int n = s.size();\n        stack<pair<int,string>> st;\n        if(n == 0) return \"\";\n        string temp;\n        int times = 0;\n        for(int i = 0; i < n;i++){\n            if(s[i] >= '0' and s[i] <= '9') times = times * 10 + s[i] - '0';\n            else if(s[i] == '['){\n                st.push({times, temp});\n                times = 0;\n                temp = \"\";\n            } else if(s[i] == ']'){\n                int time = st.top().first;\n                string a = st.top().second;\n                st.pop();\n                while(time--) a = a + temp;\n                temp = a;\n            } else {\n                temp.push_back(s[i]);\n            }\n        }\n        return temp;\n\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1290,
            "frontend_question_id": "394",
            "question_id": 394,
            "title": "字符串解码",
            "content": "<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p>\n\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像&nbsp;<code>3a</code>&nbsp;或&nbsp;<code>2[4]</code>&nbsp;的输入。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3[a]2[bc]&quot;\n<strong>输出：</strong>&quot;aaabcbc&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3[a2[c]]&quot;\n<strong>输出：</strong>&quot;accaccacc&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;2[abc]3[cd]ef&quot;\n<strong>输出：</strong>&quot;abcabccdcdcdef&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc3[cd]xyz&quot;\n<strong>输出：</strong>&quot;abccdcdcdxyz&quot;\n</pre>\n",
            "level": 2,
            "slug_title": "decode-string",
            "expand": false
        }
    },
    {
        "leetcode": 1362,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int m = coins.size();\n        // int dp[amount + 1];\n        vector<int> dp(amount + 1, INT_MAX);\n        dp[0] = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = coins[i]; j <= amount; j++){\n                int need = j - coins[i];\n                if(dp[need] == INT_MAX) continue;\n                dp[j] = min(dp[j], dp[j-coins[i]] + 1); \n            }\n        }\n        return dp[amount] == INT_MAX ? -1 : dp[amount];\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1362,
            "frontend_question_id": "322",
            "question_id": 322,
            "title": "零钱兑换",
            "content": "<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>\n\n<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>\n\n<p>你可以认为每种硬币的数量是无限的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code>\n<strong>输出：</strong><code>3</code> \n<strong>解释：</strong>11 = 5 + 5 + 1</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[2]</code>, amount = <code>3</code>\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 2\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= coins.length <= 12</code></li>\n\t<li><code>1 <= coins[i] <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 <= amount <= 10<sup>4</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "coin-change",
            "expand": false
        }
    },
    {
        "leetcode": 1384,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> t;\n        t.push_back(INT_MIN);\n        for(auto &num : nums){\n            if(num > t.back()) t.push_back(num);\n            else{\n                auto it = lower_bound(t.begin(), t.end(), num);\n                int idx = distance(t.begin(), it);\n                t[idx] = num;\n            } \n        }\n        return t.size() - 1;\n    }\n};\n// 如何要路径那么需要回溯\n```",
        "leetcodeInfo": {
            "id": 1384,
            "frontend_question_id": "300",
            "question_id": 300,
            "title": "最长上升子序列",
            "content": "<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n\n<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,3,2,3]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,7,7,7,7,7,7]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2500</code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你可以设计时间复杂度为 <code>O(n<sup>2</sup>)</code> 的解决方案吗？</li>\n\t<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>\n</ul>\n",
            "level": 2,
            "slug_title": "longest-increasing-subsequence",
            "expand": false
        }
    },
    {
        "leetcode": 1389,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass MedianFinder {\npublic:\n    priority_queue<int, vector<int>, greater<int>> pq2;\n    priority_queue<int, vector<int>, less<int>> pq1;\n\n    MedianFinder() {\n \n    }\n    \n    void addNum(int num) {\n        if(pq1.empty() or num < pq1.top()){\n            pq1.push(num);\n            if(pq1.size() - pq2.size() > 1){\n                pq2.push(pq1.top());\n                pq1.pop();\n            }\n        } else{\n            pq2.push(num);\n            if(pq2.size() - pq1.size() > 1){\n                pq1.push(pq2.top());\n                pq2.pop();\n            }\n        } \n        \n    }\n    \n    double findMedian() {\n        cout << pq1.size() << \"  \" << pq2.size() << endl;\n        int m = pq1.size(), n = pq2.size();\n        if((m + n) & 1){\n            if(m > n) return 1.0 * pq1.top();\n            else return 1.0 * pq2.top();\n        }else return 1.0 * (pq1.top() + pq2.top()) / 2.0;\n    }\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj = new MedianFinder();\n * obj->addNum(num);\n * double param_2 = obj->findMedian();\n */\n```",
        "leetcodeInfo": {
            "id": 1389,
            "frontend_question_id": "295",
            "question_id": 295,
            "title": "数据流的中位数",
            "content": "<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>\n\n<p>例如，</p>\n\n<p>[2,3,4]&nbsp;的中位数是 3</p>\n\n<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>\n\n<p>设计一个支持以下两种操作的数据结构：</p>\n\n<ul>\n\t<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>\n\t<li>double findMedian() - 返回目前所有元素的中位数。</li>\n</ul>\n\n<p><strong>示例：</strong></p>\n\n<pre>addNum(1)\naddNum(2)\nfindMedian() -&gt; 1.5\naddNum(3) \nfindMedian() -&gt; 2</pre>\n\n<p><strong>进阶:</strong></p>\n\n<ol>\n\t<li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li>\n\t<li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li>\n</ol>\n",
            "level": 3,
            "slug_title": "find-median-from-data-stream",
            "expand": false
        }
    },
    {
        "leetcode": 1445,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//单调队列 ： O(n)\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n      // queue<int> q;\n    \n      int len = nums.size(), head = 0, tail = 0;\n      vector<int> q(len+1, 0), ans;\n      for(int i = 0; i < k-1; i++){\n        while(head <= tail and q[tail] < nums[i]) tail--;\n        q[++tail] = i;\n      }\n      \n      for(int i = k-1; i < nums.size(); i++){\n        while(head <= tail and q[tail] <= nums[i]) tail--;\n        q[++tail] = i;\n        while(q[head] <= i - k) head++;\n        ans.push_back(nums[q[head]]);\n      }\n      return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1445,
            "frontend_question_id": "239",
            "question_id": 239,
            "title": "滑动窗口最大值",
            "content": "<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code><em> </em>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>\n\n<p>返回滑动窗口中的最大值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3\n<b>输出：</b>[3,3,5,5,6,7]\n<b>解释：</b>\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1], k = 1\n<b>输出：</b>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-1], k = 1\n<b>输出：</b>[1,-1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9,11], k = 2\n<b>输出：</b>[11]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,-2], k = 2\n<b>输出：</b>[4]</pre>\n\n<p> </p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= k <= nums.length</code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "sliding-window-maximum",
            "expand": false
        }
    },
    {
        "leetcode": 1448,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//递归\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n      if(not root) return nullptr;\n      if(root==p or root==q) return root;\n      \n\n      TreeNode* leftHave = lowestCommonAncestor(root->left, p, q);\n      TreeNode* rightHave = lowestCommonAncestor(root->right, p, q);\n      if(leftHave and rightHave) return root;\n      else return leftHave ? leftHave : rightHave;\n        \n    }\n};\n\n//存储父节点\nclass Solution {\npublic:\n    unordered_map<TreeNode*, TreeNode*> mp;\n    void dfs(TreeNode* root){\n      if(root->left) {mp[root->left] = root; dfs(root->left);}\n      if(root->right){mp[root->right] = root; dfs(root->right);}\n    }\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n      dfs(root);\n      mp[root] = nullptr;\n      unordered_set<TreeNode*> st;\n      while(p){\n        st.insert(p);\n        p = mp[p];\n      }\n      while(q){\n        if(st.count(q)) return q;\n        else q = mp[q];\n      }\n      return nullptr;\n        \n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1448,
            "frontend_question_id": "236",
            "question_id": 236,
            "title": "二叉树的最近公共祖先",
            "content": "<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出：</strong>5\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], p = 1, q = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[2, 10<sup>5</sup>]</code> 内。</li>\n\t<li><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code></li>\n\t<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n",
            "level": 2,
            "slug_title": "lowest-common-ancestor-of-a-binary-tree",
            "expand": false
        }
    },
    {
        "leetcode": 1458,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n      if(not root) return root;\n      queue<TreeNode*> q;\n      q.push(root);\n      while(not q.empty()){\n        TreeNode* cur = q.front();\n        q.pop();\n        TreeNode* il = cur->left;\n        cur->left = cur->right;\n        cur->right = il;\n        if(cur->left) q.push(cur->left);\n        if(cur->right) q.push(cur->right);\n      }\n      return root;\n    }\n};\n\n\n//递归\nif(not root) return root;\nTree il = inverse(root->il), ir = inverse(root->right);\nroot->left =  ir, root->right = il;\nreturn root;\n```",
        "leetcodeInfo": {
            "id": 1458,
            "frontend_question_id": "226",
            "question_id": 226,
            "title": "翻转二叉树",
            "content": "<p>翻转一棵二叉树。</p>\n\n<p><strong>示例：</strong></p>\n\n<p>输入：</p>\n\n<pre>     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9</pre>\n\n<p>输出：</p>\n\n<pre>     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1</pre>\n\n<p><strong>备注:</strong><br>\n这个问题是受到 <a href=\"https://twitter.com/mxcl\" target=\"_blank\">Max Howell </a>的 <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\">原问题</a> 启发的 ：</p>\n\n<blockquote>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</blockquote>\n",
            "level": 1,
            "slug_title": "invert-binary-tree",
            "expand": false
        }
    },
    {
        "leetcode": 1469,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n小堆堆：o(NlogK)\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n      multiset<int, greater<int>> st;\n      for(auto &num : nums){\n        st.insert(num);\n        auto last =st.end();\n        if(st.size() > k) st.erase(--last);\n      }\n      return *st.rbegin();\n      \n      \n    }\n};\n\n//基于快排\nclass Solution {\npublic:\n    //分组\n    int paritition(vector<int>& nums, int low, int high){\n      int idx = (rand() % (high-low+1));\n      swap(nums[low], nums[low+idx]);\n      int pivot = nums[low];\n      while(low < high){\n        while(low < high and nums[high] <= pivot) --high;\n        nums[low] = nums[high];\n        while(low < high and nums[low] >= pivot) ++low;\n        nums[high] = nums[low];\n      }\n      nums[low] = pivot;\n      return low;\n    }\n    //快排\n    int quickSort(vector<int>& nums, int low, int high,int index){\n      int q = paritition(nums, low, high);\n      if(q == index) return nums[q]; \n      else  return q < index ? quickSort(nums, q+1, high, index) : quickSort(nums, low, q - 1, index);\n    }\n    int findKthLargest(vector<int>& nums, int k) {\n      return quickSort(nums, 0, nums.size()-1, k-1);\n      \n\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1469,
            "frontend_question_id": "215",
            "question_id": 215,
            "title": "数组中的第K个最大元素",
            "content": "<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p>\n\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,1,5,6,4] 和</code> k = 2\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6] 和</code> k = 4\n<strong>输出:</strong> 4</pre>\n\n<p> </p>\n\n<p><strong>提示： </strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "kth-largest-element-in-an-array",
            "expand": false
        }
    },
    {
        "leetcode": 1486,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int m = nums.size();\n        vector<vector<int>> dp(m, vector<int>(2, 0));\n        dp[0][0] = 0;\n        dp[0][1] = nums[0];\n        for(int i = 1; i < m; i++){\n            dp[i][1] = dp[i-1][0] + nums[i];\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1]);\n        }\n        return max(dp[m-1][0], dp[m-1][1]);\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1486,
            "frontend_question_id": "198",
            "question_id": 198,
            "title": "打家劫舍",
            "content": "<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,7,9,3,1]\n<strong>输出：</strong>12\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>0 <= nums[i] <= 400</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "house-robber",
            "expand": false
        }
    },
    {
        "leetcode": 1515,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//投票算法\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n      int len = nums.size(), cnt = 1, cur = nums[0];\n      for(int i = 1; i < nums.size(); i++){\n        if(nums[i] == cur) cnt++;\n        else cnt--;\n        if(cnt == 0) cur = nums[i], cnt = 1;\n      }\n      return cur;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1515,
            "frontend_question_id": "169",
            "question_id": 169,
            "title": "多数元素",
            "content": "<p>给定一个大小为 <em>n </em>的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>\n\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3,2,3]\n<strong>输出：</strong>3</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,2,1,1,1,2,2]\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</li>\n</ul>\n",
            "level": 1,
            "slug_title": "majority-element",
            "expand": false
        }
    },
    {
        "leetcode": 1519,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\nclass Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n      int i = 0, j = 0, len1 = version1.size(), len2= version2.size();\n      while(i < len1 or j < len2){\n        int x = 0, y = 0;\n        while(i < len1 and version1[i] != '.'){\n          x = x * 10 + (version1[i]-'0');\n          i++;\n        }\n        i++;\n        \n        while(j < len2 and version2[j] != '.'){\n          y = y * 10 + (version2[j]-'0');\n          j++;\n        }\n        j++;\n        // cout << x << y;\n\n        if(x > y) return 1;\n        if(x < y) return -1;\n\n      }\n      return 0;\n    }\n};\n```\n```\n// 2023/12/5\nclass Solution {\npublic:\n    vector<int> spilit(const string &s){\n        vector<int> ret;   \n        int n = s.size();\n        int i = 0, j = 0;\n        while(j < n){\n            while(i < n and s[i] == '.') i++;\n            j = i;\n            while(j < n and s[j] != '.') j++;\n            if(i < n and j - i)  ret.push_back(stoi(s.substr(i, j - i)));\n            i = j;\n        }      \n        return ret;\n    }\n    int compareVersion(string version1, string version2) {\n        vector<int> v1 = spilit(version1);\n        vector<int> v2 = spilit(version2);\n        int m = v1.size(), n = v2.size(), c1, c2;\n        for(int i = 0; i < max(m,n); i++){\n            c1 = i < m ? v1[i] : 0;\n            c2 = i < n ? v2[i] : 0;\n            // cout << c1 << \" \" << c2 << endl;\n            if(c1 > c2) return 1;\n            else if(c2 > c1) return -1;\n        }\n        return 0;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1519,
            "frontend_question_id": "165",
            "question_id": 165,
            "title": "比较版本号",
            "content": "<p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>\n\n<p>版本号由一个或多个修订号组成，各修订号由一个 <code>'.'</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>\n\n<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等 </strong>。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 < 1</code> 。</p>\n\n<p>返回规则如下：</p>\n\n<ul>\n\t<li>如果 <code><em>version1 </em>> <em>version2</em></code> 返回 <code>1</code>，</li>\n\t<li>如果 <code><em>version1 </em>< <em>version2</em></code> 返回 <code>-1</code>，</li>\n\t<li>除此之外返回 <code>0</code>。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.01\", version2 = \"1.001\"\n<strong>输出：</strong>0\n<strong>解释：</strong>忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.0\", version2 = \"1.0.0\"\n<strong>输出：</strong>0\n<strong>解释：</strong>version1 没有指定下标为 2 的修订号，即视为 \"0\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"0.1\", version2 = \"1.1\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>version1 中下标为 0 的修订号是 \"0\"，version2 中下标为 0 的修订号是 \"1\" 。0 < 1，所以 version1 < version2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.0.1\", version2 = \"1\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"7.5.2.4\", version2 = \"7.5.3\"\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= version1.length, version2.length <= 500</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>'.'</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li>\n\t<li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li>\n</ul>\n",
            "level": 2,
            "slug_title": "compare-version-numbers",
            "expand": false
        }
    },
    {
        "leetcode": 1522,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int m = nums.size();\n        if(m == 1) return 0;\n        if(m == 2) return nums[0] > nums[1] ? 0 : 1;\n        int ans;\n        int l = 0, r = m-1;\n        while(l <= r){\n            cout << \"k,,,\" << l <<  \" \" << r << endl;\n            int mid = (l + r) >> 1;\n            if(mid > 0 and mid + 1 < m and nums[mid] > nums[mid-1] and nums[mid] > nums[mid+1]) return mid;\n            else if(mid + 1 < m and nums[mid + 1] > nums[mid]) l = mid + 1;\n            else if(mid > 0 and nums[mid - 1] > nums[mid]) r = mid - 1;\n            else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1522,
            "frontend_question_id": "162",
            "question_id": 162,
            "title": "寻找峰值",
            "content": "<p>峰值元素是指其值严格大于左右相邻值的元素。</p>\n\n<p>给你一个整数数组&nbsp;<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>\n\n<p>你可以假设&nbsp;<code>nums[-1] = nums[n] = -∞</code> 。</p>\n\n<p>你必须实现时间复杂度为 <code>O(log n)</code><em> </em>的算法来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = <code>[1,2,3,1]</code>\n<strong>输出：</strong>2\n<strong>解释：</strong>3 是峰值元素，你的函数应该返回其索引 2。</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = <code>[</code>1,2,1,3,5,6,4]\n<strong>输出：</strong>1 或 5 \n<strong>解释：</strong>你的函数可以返回索引 1，其峰值元素为 2；\n&nbsp;    或者返回索引 5， 其峰值元素为 6。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "find-peak-element",
            "expand": false
        }
    },
    {
        "leetcode": 1529,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\nclass MinStack {\npublic:\n    stack<pair<int,int>> st;\n    MinStack() {\n        st.push({INT_MAX, INT_MAX});\n    }\n    \n    void push(int val) {\n        st.push({val, min(val, st.top().second)});\n    }\n    \n    void pop() {\n        st.pop();\n\n    }\n    \n    int top() {\n        return st.top().first;\n    }\n    \n    int getMin() {\n        return st.top().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */\n\n```",
        "leetcodeInfo": {
            "id": 1529,
            "frontend_question_id": "155",
            "question_id": 155,
            "title": "最小栈",
            "content": "<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n\n<ul>\n\t<li><code>push(x)</code> &mdash;&mdash; 将元素 x 推入栈中。</li>\n\t<li><code>pop()</code>&nbsp;&mdash;&mdash; 删除栈顶的元素。</li>\n\t<li><code>top()</code>&nbsp;&mdash;&mdash; 获取栈顶元素。</li>\n\t<li><code>getMin()</code> &mdash;&mdash; 检索栈中的最小元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>输出：</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>解释：</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>\n</ul>\n",
            "level": 1,
            "slug_title": "min-stack",
            "expand": false
        }
    },
    {
        "leetcode": 1530,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\n将后面重复的删除，和1一样\n\n```",
        "leetcodeInfo": {
            "id": 1530,
            "frontend_question_id": "154",
            "question_id": 154,
            "title": "寻找旋转排序数组中的最小值 II",
            "content": "已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：\n<ul>\n\t<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>\n\t<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>\n</ul>\n\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n\n<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,5]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,0,1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 5000</code></li>\n\t<li><code>-5000 <= nums[i] <= 5000</code></li>\n\t<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>这道题是 <a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/\">寻找旋转排序数组中的最小值</a> 的延伸题目。</li>\n\t<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>\n</ul>\n",
            "level": 3,
            "slug_title": "find-minimum-in-rotated-sorted-array-ii",
            "expand": false
        }
    },
    {
        "leetcode": 1531,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int ans = nums[0];\n        if(nums.back() >= nums[0]) return nums[0];\n        int l = 0, r = nums.size(), pivot = nums[0];\n        while(l <= r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] >= pivot){\n                l = mid + 1;\n            }else{\n                ans = nums[mid];\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1531,
            "frontend_question_id": "153",
            "question_id": 153,
            "title": "寻找旋转排序数组中的最小值",
            "content": "已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：\n<ul>\n\t<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>\n\t<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>\n</ul>\n\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n\n<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,6,7,0,1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,13,15,17]\n<strong>输出：</strong>11\n<strong>解释：</strong>原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 5000</code></li>\n\t<li><code>-5000 <= nums[i] <= 5000</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n",
            "level": 2,
            "slug_title": "find-minimum-in-rotated-sorted-array",
            "expand": false
        }
    },
    {
        "leetcode": 1533,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n\n//双指针\nclass Solution {\npublic:\n    string reverseWords(string s) {\n      int len = s.size(), i = len-1, j = len-1;\n      string ans;\n      while(i >= 0 and j >= 0){\n        while(i >= 0 and s[i] == ' ') i--;\n        j = i;\n        while(j >= 0 and s[j] != ' ') j--;\n        if(i >= 0) ans += s.substr(j+1, i-j) + \" \";\n        i = j-1;\n      }\n      ans.pop_back();\n      return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1533,
            "frontend_question_id": "151",
            "question_id": 151,
            "title": "翻转字符串里的单词",
            "content": "<p>给你一个字符串 <code>s</code> ，逐个翻转字符串中的所有 <strong>单词</strong> 。</p>\n\n<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>\n\n<p>请你返回一个翻转 <code>s</code> 中单词顺序并用单个空格相连的字符串。</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>输入字符串 <code>s</code> 可以在前面、后面或者单词间包含多余的空格。</li>\n\t<li>翻转后单词间应当仅用一个空格分隔。</li>\n\t<li>翻转后的字符串中不应包含额外的空格。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"<code>the sky is blue</code>\"\n<strong>输出：</strong>\"<code>blue is sky the</code>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"  hello world  \"\n<strong>输出：</strong>\"world hello\"\n<strong>解释：</strong>输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a good   example\"\n<strong>输出：</strong>\"example good a\"\n<strong>解释：</strong>如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"  Bob    Loves  Alice   \"\n<strong>输出：</strong>\"Alice Loves Bob\"\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Alice does not even like bob\"\n<strong>输出：</strong>\"bob like even not does Alice\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li>\n\t<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>\n</ul>\n\n<ul>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>请尝试使用 <code><em>O</em>(1)</code> 额外空间复杂度的原地解法。</li>\n</ul>\n",
            "level": 2,
            "slug_title": "reverse-words-in-a-string",
            "expand": false
        }
    },
    {
        "leetcode": 1536,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n      if(not head or not head->next) return head;\n      int len = 0;\n      ListNode* fake = new ListNode(-1,head), *first, *second, *cur = head, *prev;\n      while(cur) len++, cur=cur->next;\n      for (int subLength = 1; subLength < len; subLength <<= 1) {\n        prev = fake, cur = fake->next;\n        while(cur != nullptr){\n          //分别找到两个链表\n          first = cur;\n          for(int i = 1; i < subLength and cur->next; i++) cur=cur->next;\n\n          //获取本组第二个链表的起始节点\n          second = cur->next, cur->next = nullptr, cur = second;\n          for(int i = 1; i < subLength and cur and cur->next; i++) cur=cur->next;\n\n          //获取下一个节点，并断开这一组与下一组的指针\n          ListNode *next = nullptr;\n          if(cur != nullptr) next = cur->next, cur->next = nullptr;\n\n          //合并两个链表\n          ListNode *merged = merge(first, second);\n\n          //链接这一组和上一组，并将prev指向下一组的前一个节点\n          prev->next = merged;\n          while(prev->next) prev=prev->next;\n\n          //将cur指向下一组的第一个节点\n          cur = next;\n        }\n      }\n      return fake->next;\n    }\n\n    ListNode* merge(ListNode* la, ListNode* lb){\n      ListNode *fake = new ListNode(-1), *cur = fake;\n      while(la or lb){\n        if(la and lb){\n          if(la->val < lb->val) cur->next = la, la=la->next;\n          else cur->next=lb, lb = lb->next;\n        }else if(la) cur->next = la, la = la->next;\n        else cur->next = lb, lb=lb->next;\n        cur = cur->next;\n      } \n      return fake->next;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1536,
            "frontend_question_id": "148",
            "question_id": 148,
            "title": "排序链表",
            "content": "<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 302px; \"/>\n<pre>\n<b>输入：</b>head = [4,2,1,3]\n<b>输出：</b>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 402px; \" />\n<pre>\n<b>输入：</b>head = [-1,5,3,4,0]\n<b>输出：</b>[-1,0,3,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>head = []\n<b>输出：</b>[]\n</pre>\n\n<p> </p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 5 * 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "sort-list",
            "expand": false
        }
    },
    {
        "leetcode": 1546,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\n\n\n迭代方法： 在每一个节点的后一个位置插入copy节点，随后再修改random指针，最后再复原原有链表\n递归方法： 使用map进行映射node和copyNode之间的关系\n\n//递归\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n      if(not head) return head;\n\n      //插入新节点\n      for(auto cur = head; cur ; cur = cur->next->next){\n        Node *newNode = new Node(cur->val);\n        newNode->next = cur->next;\n        cur->next = newNode;\n      }\n\n      //更改rando节点\n      for(auto cur = head; cur; cur = cur->next->next){\n        if(not cur->random) continue;\n        cur->next->random = cur->random->next;\n      }\n\n\n      Node *ans = head->next;\n      Node *cur = head;\n      //更改next指针\n      while(cur->next->next){\n        Node* nextNode = cur->next->next;\n        cur->next->next = nextNode->next;\n        cur->next = nextNode;\n        cur = cur->next;\n      }\n      //不要修改最后一个指针\n      cur->next = nullptr;\n      return ans;      \n  }\n};\n```",
        "leetcodeInfo": {
            "id": 1546,
            "frontend_question_id": "138",
            "question_id": 138,
            "title": "复制带随机指针的链表",
            "content": "<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>\n\n<p>构造这个链表的 <strong><a href=\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\" target=\"_blank\">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点 </strong>。</p>\n\n<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --> Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --> y</code> 。</p>\n\n<p>返回复制链表的头节点。</p>\n\n<p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>\n\n<ul>\n\t<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>\n\t<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。</li>\n</ul>\n\n<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png\" style=\"height: 138px; width: 680px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png\" style=\"height: 111px; width: 680px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [[1,1],[2,1]]\n<strong>输出：</strong>[[1,1],[2,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png\" style=\"height: 119px; width: 680px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [[3,null],[3,0],[3,null]]\n<strong>输出：</strong>[[3,null],[3,0],[3,null]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n<strong>解释：</strong>给定的链表为空（空指针），因此返回 null。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 1000</code></li>\n\t<li><code>-10000 <= Node.val <= 10000</code></li>\n\t<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>\n</ul>\n",
            "level": 2,
            "slug_title": "copy-list-with-random-pointer",
            "expand": false
        }
    },
    {
        "leetcode": 1547,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n## 主要思路\n - 使用位统计，将所有数字的位进行累计\n - 对于不被3整除的位，说明是该单独元素\n - 构造答案\n\n```\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        vector<int> bits(32, 0);\n        for(auto &num : nums){\n            for(int i = 0; i < 32; i++) bits[i] += (num >> i) & 1;\n        }\n        for(auto bit : bits) cout << bit << \" \";\n        int ans = 0;\n        for(int i = 0; i < 32; i++){\n            ans <<= 1;\n            if(bits[31 - i] % 3 == 1) ans |= 1;\n        }\n        return ans;\n    }\n};```",
        "leetcodeInfo": {
            "id": 1547,
            "frontend_question_id": "137",
            "question_id": 137,
            "title": "只出现一次的数字 II",
            "content": "<p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,3,2]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,1,0,1,99]\n<strong>输出：</strong>99\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n",
            "level": 2,
            "slug_title": "single-number-ii",
            "expand": false
        }
    },
    {
        "leetcode": 1548,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//位运算、Hash、排序、暴力\n```",
        "leetcodeInfo": {
            "id": 1548,
            "frontend_question_id": "136",
            "question_id": 136,
            "title": "只出现一次的数字",
            "content": "<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n\n<p><strong>说明：</strong></p>\n\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [2,2,1]\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [4,1,2,1,2]\n<strong>输出:</strong> 4</pre>\n",
            "level": 1,
            "slug_title": "single-number",
            "expand": false
        }
    },
    {
        "leetcode": 1549,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int m = ratings.size(); \n        vector<int> candies = vector<int>(m, 0);\n        candies[0] = 1;\n        for(int i = 1; i < m; i++){\n            if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n            else candies[i] = 1;\n        }\n        for(int j = m-2; j >= 0; j--){\n            if(ratings[j] > ratings[j+1]) candies[j] = max(candies[j], candies[j+1] + 1);\n        }\n        return accumulate(candies.begin(), candies.end(), 0);\n\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1549,
            "frontend_question_id": "135",
            "question_id": 135,
            "title": "分发糖果",
            "content": "<p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>\n\n<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>\n\n<ul>\n\t<li>每个孩子至少分配到 1 个糖果。</li>\n\t<li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li>\n</ul>\n\n<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,0,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以分别给这三个孩子分发 2、1、2 颗糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以分别给这三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</pre>\n",
            "level": 3,
            "slug_title": "candy",
            "expand": false
        }
    },
    {
        "leetcode": 1556,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n存入hash中，然后遍历每个数段即可\n```",
        "leetcodeInfo": {
            "id": 1556,
            "frontend_question_id": "128",
            "question_id": 128,
            "title": "最长连续序列",
            "content": "<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>\n\n<p>请你设计并实现时间复杂度为 <code>O(n)</code><em> </em>的算法解决此问题。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100,4,200,1,3,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长数字连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "longest-consecutive-sequence",
            "expand": false
        }
    },
    {
        "leetcode": 1560,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = INT_MIN;\n    int recursion(TreeNode* root){\n        if(not root) return 0;\n        int leftMax = recursion(root->left);\n        int rightMax = recursion(root->right);\n        ans = max(ans, leftMax + rightMax + root->val);\n        return max(0, max(leftMax + root->val, rightMax + root->val));\n    }\n    int maxPathSum(TreeNode* root) {\n        recursion(root);\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1560,
            "frontend_question_id": "124",
            "question_id": 124,
            "title": "二叉树中的最大路径和",
            "content": "<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>\n\n<p><strong>路径和</strong> 是路径中各节点值的总和。</p>\n\n<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>输入：</strong>root = [-10,9,20,null,null,15,7]\n<strong>输出：</strong>42\n<strong>解释：</strong>最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "binary-tree-maximum-path-sum",
            "expand": false
        }
    },
    {
        "leetcode": 1561,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;\n        int ans = 0;\n        for(int i = 1; i < (int)prices.size(); i++){\n            buy1 = max(buy1, -prices[i]);\n            sell1 = max(sell1, buy1 + prices[i]);\n            buy2  = max(buy2, sell1 - prices[i]);\n            sell2 = max(sell2, buy2 + prices[i]);\n        }\n        return max(sell1, sell2);\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1561,
            "frontend_question_id": "123",
            "question_id": 123,
            "title": "买卖股票的最佳时机 III",
            "content": "<p>给定一个数组，它的第<em> </em><code>i</code> 个元素是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p>\n\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔 </strong>交易。</p>\n\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [3,3,5,0,0,3,1,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1,2,3,4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,6,4,3,1] \n<strong>输出：</strong>0 \n<strong>解释：</strong>在这个情况下, 没有交易完成, 所以最大利润为 0。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= prices.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= prices[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "best-time-to-buy-and-sell-stock-iii",
            "expand": false
        }
    },
    {
        "leetcode": 1570,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if(not root) return;\n        flatten(root->left);\n        flatten(root->right);\n        if(not root->left) return;\n        TreeNode* cur = root->left;\n        while(cur->right) cur = cur->right;\n        cur->right = root->right;\n        // if(not root->left) \n        root->right = root->left;\n        root->left = nullptr;\n       \n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1570,
            "frontend_question_id": "114",
            "question_id": 114,
            "title": "二叉树展开为链表",
            "content": "<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>\n\n<ul>\n\t<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>\n\t<li>展开后的单链表应该与二叉树 <a href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\" target=\"_blank\"><strong>先序遍历</strong></a> 顺序相同。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,5,3,4,null,6]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>\n",
            "level": 2,
            "slug_title": "flatten-binary-tree-to-linked-list",
            "expand": false
        }
    },
    {
        "leetcode": 1575,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    TreeNode* root;\n    void build(ListNode* root){\n\n        \n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(not head) return nullptr;\n        if(not head->next) return new TreeNode(head->val);\n        ListNode* slow = head, *fast = head->next->next;\n        while(fast){\n            if(fast->next and fast->next->next) fast = fast->next->next;\n            else break;\n            slow = slow->next;\n        }\n\n        ListNode* mid = slow->next;\n        slow->next = nullptr;\n        TreeNode* leftNode = sortedListToBST(head);\n        TreeNode* rightNode = sortedListToBST(mid->next);\n        TreeNode* cur = new TreeNode(mid->val, leftNode, rightNode);\n        return cur;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1575,
            "frontend_question_id": "109",
            "question_id": 109,
            "title": "有序链表转换二叉搜索树",
            "content": "<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>\n\n<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点&nbsp;</em>的左右两个子树的高度差的绝对值不超过 1。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n</pre>\n",
            "level": 2,
            "slug_title": "convert-sorted-list-to-binary-search-tree",
            "expand": false
        }
    },
    {
        "leetcode": 1582,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    void dfs(TreeNode* root, int level){\n        if(not root) return;\n        if(ans.size() < level) ans.push_back(vector<int>());\n        \n        ans[level - 1].push_back(root->val);\n\n\n        dfs(root->left, level + 1);\n        dfs(root->right, level + 1);\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        dfs(root, 1);\n        return ans;\n    }\n};\n\n//this is dfs method\n```",
        "leetcodeInfo": {
            "id": 1582,
            "frontend_question_id": "102",
            "question_id": 102,
            "title": "二叉树的层序遍历",
            "content": "<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong><br />\n二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其层序遍历结果：</p>\n\n<pre>\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n</pre>\n",
            "level": 2,
            "slug_title": "binary-tree-level-order-traversal",
            "expand": false
        }
    },
    {
        "leetcode": 1583,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n\n## 迭代\n```\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        queue<TreeNode*> q;\n        if(not root) return true;\n        q.push(root->left);\n        q.push(root->right);\n        while(not q.empty()){\n            TreeNode* left = q.front(); q.pop();\n            TreeNode* right = q.front(); q.pop();\n            if(not left and not right) continue;\n            if(left and right){\n                if(left->val != right->val) return false;\n                q.push(left->left);\n                q.push(right->right);\n                q.push(left->right);\n                q.push(right->left);\n            }else return false;\n        }\n        return true;\n    }\n};\n```\n\n## 递归\n```c++\nclass Solution {\npublic:\n    bool check(TreeNode* r1, TreeNode* r2){\n        if(not r1 and not r2) return true;\n        else return r1 and r2 and r1->val == r2->val and check(r1->left, r2->right) and check(r1->right, r2->left);\n    }\n    bool isSymmetric(TreeNode* root) {\n        return check(root, root);\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1583,
            "frontend_question_id": "101",
            "question_id": 101,
            "title": "对称二叉树",
            "content": "<p>给定一个二叉树，检查它是否是镜像对称的。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，二叉树&nbsp;<code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n\n<pre>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</pre>\n\n<p>&nbsp;</p>\n\n<p>但是下面这个&nbsp;<code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n\n<pre>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>\n",
            "level": 1,
            "slug_title": "symmetric-tree",
            "expand": false
        }
    },
    {
        "leetcode": 1586,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\n// 递归\nclass Solution {\npublic:\n    long long pre = LONG_MIN;\n    bool isValidBST(TreeNode* root) {\n        if(not root) return true;\n        // bool curVal;\n        bool preVal = isValidBST(root->left);\n        bool curVal = root->val > pre;\n        pre = root->val;\n        bool afterVal = isValidBST(root->right);  \n        return preVal and curVal and afterVal;\n    }\n};\n\n//迭代\nclass Solution {\npublic:\n    long long pre = LONG_MIN;\n    bool ans = true;\n    bool isValidBST(TreeNode* root) {\n        if(not root) return true;\n        stack<TreeNode*> st;\n        while(not st.empty() or root){\n            while(root){\n                st.push(root);\n                root = root->left;\n            }\n            root = st.top(); st.pop();\n            if(root->val <= pre) return false;\n            else pre = root->val;\n            root = root->right;  \n        }\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1586,
            "frontend_question_id": "98",
            "question_id": 98,
            "title": "验证二叉搜索树",
            "content": "<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>\n\n<p><strong>有效</strong> 二叉搜索树定义如下：</p>\n\n<ul>\n\t<li>节点的左子树只包含<strong> 小于 </strong>当前节点的数。</li>\n\t<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>\n\t<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>输入：</strong>root = [5,1,4,null,null,3,6]\n<strong>输出：</strong>false\n<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围在<code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "validate-binary-search-tree",
            "expand": false
        }
    },
    {
        "leetcode": 1587,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int m = s1.size(), n = s2.size();\n        if(m + n != (int)s3.size()) return false;\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n        dp[0][0] = true;\n        for(int i = 0; i <= m; i++){\n            for(int j = 0;  j <= n; j++){\n                if(i == 0 and j == 0) continue;\n                int k = i + j - 1;\n                if(i and s3[k] == s1[i-1]) dp[i][j] = dp[i][j] or dp[i-1][j];\n                if(j and s3[k] == s2[j-1]) dp[i][j] = dp[i][j-1] or dp[i][j];\n            }\n        }\n        return dp[m][n];\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1587,
            "frontend_question_id": "97",
            "question_id": 97,
            "title": "交错字符串",
            "content": "<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code><em> </em><strong>交错 </strong>组成的。</p>\n\n<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| <= 1</code></li>\n\t<li><strong>交错</strong> 是 <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> 或者 <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"\", s2 = \"\", s3 = \"\"\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s1.length, s2.length <= 100</code></li>\n\t<li><code>0 <= s3.length <= 200</code></li>\n\t<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>\n</ul>\n",
            "level": 2,
            "slug_title": "interleaving-string",
            "expand": false
        }
    },
    {
        "leetcode": 1591,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<int> nums;\n    void dfs(string &s, int idx){\n        if(nums.size() > 4) return;\n        if(idx >= s.size()){\n            string ip = \"\";\n            if(nums.size() == 4){\n                for(auto num : nums) ip += to_string(num) + \".\";\n                ip.pop_back();\n                ans.push_back(ip);\n            }\n            return;\n        }\n\n        for(int i = idx; i < s.size() and idx - i + 1 <= 3; i++){\n            string temp = s.substr(idx, i - idx + 1);\n            int num = stoi(temp);\n            if(num > 255) break;a\n            else{\n                nums.push_back(num);\n                dfs(s, i + 1);\n                nums.pop_back();\n                if(num == 0) break;\n            }\n        }\n        \n\n    }\n    vector<string> restoreIpAddresses(string s) {\n        int n = s.size();\n        if(s.size() < 4) return ans;\n        dfs(s, 0);\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1591,
            "frontend_question_id": "93",
            "question_id": 93,
            "title": "复原IP地址",
            "content": "<p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 <code>s</code> 获得的 <strong>有效 IP 地址 </strong>。你可以按任何顺序返回答案。</p>\n\n<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>\n\n<p>例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是 <strong>有效</strong> IP 地址，但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是 <strong>无效</strong> IP 地址。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"25525511135\"\n<strong>输出：</strong>[\"255.255.11.135\",\"255.255.111.35\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0000\"\n<strong>输出：</strong>[\"0.0.0.0\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1111\"\n<strong>输出：</strong>[\"1.1.1.1\"]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010010\"\n<strong>输出：</strong>[\"0.10.0.10\",\"0.100.1.0\"]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"101023\"\n<strong>输出：</strong>[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 3000</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
            "level": 2,
            "slug_title": "restore-ip-addresses",
            "expand": false
        }
    },
    {
        "leetcode": 1594,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> temp;\n    vector<bool> have;\n    void dfs(vector<int>& nums, int cur){\n        if(cur == nums.size()){\n            ans.push_back(vector<int>(temp.begin(), temp.end()));\n            return;\n        }\n        // insert\n        temp.push_back(nums[cur]);\n        have[cur] = true;\n        dfs(nums, cur + 1);\n        temp.pop_back();\n        have[cur] = false;\n\n        //not insert\n        // if nums[cur-1], nums[cur] are same and have not selected nums[cur], nums[cur-1] must be not selected. \n        if(cur > 0 and nums[cur] == nums[cur-1] and have[cur-1]) return;\n        dfs(nums, cur+1);\n    }\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = nums.size();\n        have = vector<bool>(m, false);\n        dfs(nums, 0);\n        return ans;\n    }\n};\n\n```",
        "leetcodeInfo": {
            "id": 1594,
            "frontend_question_id": "90",
            "question_id": 90,
            "title": "子集 II",
            "content": "<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>\n\n<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2]\n<strong>输出：</strong>[[],[1],[1,2],[1,2,2],[2],[2,2]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[[],[0]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10</code></li>\n\t<li><code>-10 <= nums[i] <= 10</code></li>\n</ul>\n</div>\n</div>\n",
            "level": 2,
            "slug_title": "subsets-ii",
            "expand": false
        }
    },
    {
        "leetcode": 1605,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int xx[4] = {0, 1, 0, -1}, yy[4] = {1, 0, -1, 0};\n    int m,n;\n    bool can = false;\n    void backTrace(vector<vector<char>> &board, const string &word, int ci, int cj, int k){\n        if(board[ci][cj] != word[k]) return;\n        if(word.size() - 1 == k and board[ci][cj] == word.back()){\n            can = true;\n            return;\n        }\n        if(can) return;\n        char old = board[ci][cj];\n        board[ci][cj] = ' '; \n        for(int i = 0; i < 4; i++){\n            int ni = xx[i] + ci, nj = yy[i] + cj;\n            if(ni >= 0 and ni < m and nj >= 0 and nj < n) backTrace(board, word, ni, nj, k + 1);\n        }\n        board[ci][cj] = old;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        m = board.size(), n = board[0].size();\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                backTrace(board, word, i, j, 0);\n                if(can) return true;       \n            }\n        }\n        return false;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1605,
            "frontend_question_id": "79",
            "question_id": 79,
            "title": "单词搜索",
            "content": "<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 <= m, n <= 6</code></li>\n\t<li><code>1 <= word.length <= 15</code></li>\n\t<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>\n",
            "level": 2,
            "slug_title": "word-search",
            "expand": false
        }
    },
    {
        "leetcode": 1608,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    unordered_map<char, int> need;\n    unordered_map<char, int> mp;\n    bool check(){\n        for(auto &[ch, cnt] : need){\n            if(mp[ch] < cnt) return false;\n        }\n        return true;\n    }\n    string minWindow(string s, string t) {\n        int minL = INT_MAX;\n        string ans = \"\";\n        bool can = false;\n        for(auto &ch : t) need[ch]++;\n        int n = s.size();\n        for(int i = 0, j = 0; j < n; j++){\n            mp[s[j]]++;\n            can = false;\n            while(i <= j and check()){ \n                mp[s[i]]--;\n                i++;\n                can = true;\n            }\n            if(can){\n                if(j - i + 2 < minL){\n                    minL = j - i + 2;\n                    ans = s.substr(i-1, j - i + 2);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1608,
            "frontend_question_id": "76",
            "question_id": 76,
            "title": "最小覆盖子串",
            "content": "<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>\"\"</code> 。</p>\n\n<p> </p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>\n\t<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ADOBECODEBANC\", t = \"ABC\"\n<strong>输出：</strong>\"BANC\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\", t = \"a\"\n<strong>输出：</strong>\"a\"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"a\", t = \"aa\"\n<strong>输出:</strong> \"\"\n<strong>解释:</strong> t 中两个字符 'a' 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length, t.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p> </p>\n<strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？",
            "level": 3,
            "slug_title": "minimum-window-substring",
            "expand": false
        }
    },
    {
        "leetcode": 1610,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n\n        int l, r, row = -1, col;\n        \n\n        l = 0, r = (int)matrix.size() - 1;\n        while(l <= r){\n            int mid = (l + r) >> 1;\n            if(matrix[mid][0] == target) return true;\n            else if(matrix[mid][0] < target){\n                row = mid;\n                l = mid + 1;\n            }else r = mid - 1;\n        }\n        if(row == -1) return false;\n        cout << row << endl;\n\n        l = 0, r = (int)matrix[0].size() - 1;\n        while(l <= r){\n            int mid = (l + r) >> 1;\n            if(matrix[row][mid] == target) return true;\n            else if(matrix[row][mid] < target) l = mid + 1;\n            else r = mid - 1;\n        }\n        return false;\n\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1610,
            "frontend_question_id": "74",
            "question_id": 74,
            "title": "搜索二维矩阵",
            "content": "<p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>\n\n<ul>\n\t<li>每行中的整数从左到右按升序排列。</li>\n\t<li>每行的第一个整数大于前一行的最后一个整数。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>-10<sup>4</sup> <= matrix[i][j], target <= 10<sup>4</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "search-a-2d-matrix",
            "expand": false
        }
    },
    {
        "leetcode": 1612,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\ndp[i][j]代表从w1的前i个字符转换到 w2的前jg个字符的最小次数\nif(word[i-1] == word[j-1]) dp[i][j] = dp[i-1][j-1]\nelse dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\n分别对应 修改操作，删除操作， 增加操作\n```",
        "leetcodeInfo": {
            "id": 1612,
            "frontend_question_id": "72",
            "question_id": 72,
            "title": "编辑距离",
            "content": "<p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code><em> </em>所使用的最少操作数 。</p>\n\n<p>你可以对一个单词进行如下三种操作：</p>\n\n<ul>\n\t<li>插入一个字符</li>\n\t<li>删除一个字符</li>\n\t<li>替换一个字符</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"horse\", word2 = \"ros\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"intention\", word2 = \"execution\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= word1.length, word2.length <= 500</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
            "level": 3,
            "slug_title": "edit-distance",
            "expand": false
        }
    },
    {
        "leetcode": 1625,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        int cur = 1;\n        vector<vector<int>> ans = vector<vector<int>>(n, vector<int>(n,0));\n        int top = 0, bottom = n-1, left = 0, right = n-1;\n        int i = 0, j = 0;\n        while(cur <= n * n){\n            for(int i = left; i <= right; i++)  ans[top][i] = cur++;\n            ++top;\n            for(int j = top; j <= bottom; j++) ans[j][right] = cur++;\n            right--;\n            for(int i = right; i >= left; i--)  ans[bottom][i] = cur++;\n            bottom--;\n            for(int j = bottom; j >= top; j--) ans[j][left] = cur++;\n            left++;\n        }\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1625,
            "frontend_question_id": "59",
            "question_id": 59,
            "title": "螺旋矩阵 II",
            "content": "<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n<sup>2</sup></code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "spiral-matrix-ii",
            "expand": false
        }
    },
    {
        "leetcode": 1629,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int curMax = 0;\n        for(int i = 0; i < (int)nums.size(); i++){\n            if(i > curMax) return false;\n            curMax = max(nums[i] + i, curMax);\n        }\n        return true;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1629,
            "frontend_question_id": "55",
            "question_id": 55,
            "title": "跳跃游戏",
            "content": "<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n\n<p>判断你是否能够到达最后一个下标。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1,1,4]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,0,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "jump-game",
            "expand": false
        }
    },
    {
        "leetcode": 1630,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<int> ans;\n        if(matrix.empty()) return ans;\n        int u = 0, d = matrix.size()-1, l = 0, r = matrix[0].size()-1;\n        while(true){\n            for(int i = l; i <= r; i++) ans.push_back(matrix[u][i]);\n            if(++u > d) break;\n            for(int i = u; i <= d; i++) ans.push_back(matrix[i][r]);\n            if(--r < l) break;\n            for(int i = r; i >= l; i--) ans.push_back(matrix[d][i]);\n            if(--d < u) break;\n            for(int i = d; i >= u; i--) ans.push_back(matrix[i][l]);\n            if(++l > r) break;\n        }\n        return ans;\n    }\n};\n```\n\nlrdu:上下左右四个边界即可",
        "leetcodeInfo": {
            "id": 1630,
            "frontend_question_id": "54",
            "question_id": 54,
            "title": "螺旋矩阵",
            "content": "<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 10</code></li>\n\t<li><code>-100 <= matrix[i][j] <= 100</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "spiral-matrix",
            "expand": false
        }
    },
    {
        "leetcode": 1636,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n// 主对角线对称，然后垂直中轴线对称\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n       int m = matrix.size();\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j <= i; j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < (m >> 1); j++){\n                swap(matrix[i][j], matrix[i][m-1-j]);\n            }\n        }\n        return;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1636,
            "frontend_question_id": "48",
            "question_id": 48,
            "title": "旋转图像",
            "content": "<p>给定一个 <em>n </em>× <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>\n\n<p>你必须在<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要 </strong>使用另一个矩阵来旋转图像。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"width: 642px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"width: 800px; height: 321px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1]]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2],[3,4]]\n<strong>输出：</strong>[[3,1],[4,2]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>matrix.length == n</code></li>\n\t<li><code>matrix[i].length == n</code></li>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>-1000 <= matrix[i][j] <= 1000</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "rotate-image",
            "expand": false
        }
    },
    {
        "leetcode": 1637,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<bool> visited;\n    vector<int> temp;\n    vector<vector<int>> ans;\n    int m;\n    void dfs(vector<int>& nums, int k){\n        if(k == m){\n            ans.push_back(vector<int>(temp.begin(), temp.end()));\n            return;\n        }\n        for(int i = 0; i < m; i++){\n            if(visited[i]) continue;\n            if(i > 0 and nums[i] == nums[i-1] and not visited[i-1]) continue;\n            temp.push_back(nums[i]);\n            visited[i] = true;\n            dfs(nums, k + 1);\n            temp.pop_back();\n            visited[i] = false;\n        }\n        \n        \n    }\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        m = nums.size();\n        visited = vector<bool>(m, false);\n        sort(nums.begin(), nums.end());\n        dfs(nums, 0);\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1637,
            "frontend_question_id": "47",
            "question_id": 47,
            "title": "全排列 II",
            "content": "<p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 8</code></li>\n\t<li><code>-10 <= nums[i] <= 10</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "permutations-ii",
            "expand": false
        }
    },
    {
        "leetcode": 1641,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    string multiply(string num1, string num2) {\n        int m = num1.size(), n = num2.size();\n        if(num1 == \"0\" or num2 == \"0\") return \"0\";\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        vector<int> ans = vector<int>(m + n + 1, 0);\n        int curBit = 0, carry = 0;\n        for(int j = 0; j < n; j++){\n            for(int i = 0; i < m; i++){\n                int curVal = (num1[i] - '0') * (num2[j] - '0');\n                ans[i+j] += (carry + curVal);\n                carry = ans[i+j] / 10;\n                ans[i+j] %= 10;\n            }\n            if(carry != 0) ans[j+m] += carry;\n            carry = 0;\n        }\n        while(not ans.empty() and ans.back() == 0) ans.pop_back();\n        string ret;\n        for(auto num : ans) ret.push_back(num + '0');\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1641,
            "frontend_question_id": "43",
            "question_id": 43,
            "title": "字符串相乘",
            "content": "<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;2&quot;, num2 = &quot;3&quot;\n<strong>输出:</strong> &quot;6&quot;</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> num1 = &quot;123&quot;, num2 = &quot;456&quot;\n<strong>输出:</strong> &quot;56088&quot;</pre>\n\n<p><strong>说明：</strong></p>\n\n<ol>\n\t<li><code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的长度小于110。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code> 只包含数字&nbsp;<code>0-9</code>。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;均不以零开头，除非是数字 0 本身。</li>\n\t<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>\n</ol>\n",
            "level": 2,
            "slug_title": "multiply-strings",
            "expand": false
        }
    },
    {
        "leetcode": 1642,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//单调栈做法\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n      int len = height.size();\n      stack<int> st;\n      int ans = 0;\n      // st.push_back(INT_MAX);\n      for(int i = 0; i < len; i++){\n        while(not st.empty() && height[i] > height[st.top()]){\n          int top = st.top();\n          st.pop();\n          if(st.empty()) break;\n          int left = st.top();\n          int width = i - left - 1, heigh = min(height[i], height[left]) - height[top];\n          ans += width * heigh;\n        }\n        st.push(i);\n      }\n      return ans;\n    }\n};\n\n//双指针O(1)空间做法\n/**\n搬运一个对解法四中双指针的解释： 可算看懂了，原来双指针同时开两个柱子接水。大家题解没说清楚，害得我也没看懂。 对于每一个柱子接的水，那么它能接的水=min(左右两边最高柱子）-当前柱子高度，这个公式没有问题。同样的，两根柱子要一起求接水，同样要知道它们左右两边最大值的较小值。\n问题就在这，假设两柱子分别为 i，j。那么就有 iLeftMax,iRightMax,jLeftMx,jRightMax 这个变量。由于 j>i ，故 jLeftMax>=iLeftMax，iRigthMax>=jRightMax.\n那么，如果 iLeftMax>jRightMax，则必有 jLeftMax >= jRightMax，所有我们能接 j 点的水。\n如果 jRightMax>iLeftMax，则必有 iRightMax >= iLeftMax，所以我们能接 i 点的水。\n而上面我们实际上只用到了 iLeftMax，jRightMax 两个变量，故我们维护这两个即可。（题解都没说清楚，就说个 LeftMax，RightMax，谁知道为什么就可以这么做了。)\n**/\n//证明如下\n// 假设有 ileftMax, irightMax, jleftMax, jrightMax\n// ileftMax <= jleftMax, iRigthMax >= jRightMax\n// 如果 ileftMax < jrightMax 那么 ileftMax < iRightMax, 必定取下标i\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n      int len = height.size();\n      int l = 0, r = len - 1, lm = 0, rm = 0, ans = 0;\n      while(l < r){\n        lm = max(lm, height[l]);\n        rm = max(rm, height[r]);\n        if(height[l] < height[r]){\n          ans += lm - height[l];\n          l++;\n        }else{\n          ans += rm - height[r];\n          r--;\n        }\n      }\n      return ans;\n\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1642,
            "frontend_question_id": "42",
            "question_id": 42,
            "title": "接雨水",
            "content": "<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" style=\"height: 161px; width: 412px;\" /></p>\n\n<pre>\n<strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [4,2,0,3,2,5]\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>0 <= n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= height[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "trapping-rain-water",
            "expand": false
        }
    },
    {
        "leetcode": 1643,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    \n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            while(nums[i] != i + 1){\n                if(nums[i] > n or nums[i] <= 0) break;\n                else if(nums[i] == nums[nums[i]-1]) break;\n                swap(nums[i], nums[nums[i]-1]);\n            }\n        }\n        for(int i = 0; i < n; i++) if(nums[i] != i + 1) return i + 1;\n        return n + 1;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1643,
            "frontend_question_id": "41",
            "question_id": 41,
            "title": "缺失的第一个正数",
            "content": "<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>\n请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,-1,1]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,8,9,11,12]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "first-missing-positive",
            "expand": false
        }
    },
    {
        "leetcode": 1644,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<bool> isVisited;\n    vector<vector<int>> ans;\n    vector<int> temp;\n    void dfs(vector<int>& candidates, int target, int k, int cur){\n        if(target == cur){\n            ans.push_back(vector<int>(temp.begin(), temp.end()));\n            return;\n        }\n\n        if(k == candidates.size() or cur > target) return;\n        for(int i = k; i < (int)candidates.size(); i++){\n            if(i and candidates[i] == candidates[i-1] and not isVisited[i-1]) continue;\n            temp.push_back(candidates[i]);\n            isVisited[i] = true;\n            dfs(candidates, target, i + 1, cur + candidates[i]);\n            temp.pop_back();\n            isVisited[i] = false;\n        }\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        int m = candidates.size();\n        sort(candidates.begin(), candidates.end());\n        isVisited = vector<bool>(m, false);\n        dfs(candidates, target, 0, 0);\n        return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1644,
            "frontend_question_id": "40",
            "question_id": 40,
            "title": "组合总和 II",
            "content": "<p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>\n\n<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>\n\n<p><strong>注意：</strong>解集不能包含重复的组合。 </p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates = <code>[10,1,2,7,6,1,5]</code>, target = <code>8</code>,\n<strong>输出:</strong>\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates = [2,5,2,1,2], target = 5,\n<strong>输出:</strong>\n[\n[1,2,2],\n[5]\n]</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= candidates.length <= 100</code></li>\n\t<li><code>1 <= candidates[i] <= 50</code></li>\n\t<li><code>1 <= target <= 30</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "combination-sum-ii",
            "expand": false
        }
    },
    {
        "leetcode": 1650,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//两次二分即可\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n      int left = -1, right = -1;\n      int l = 0, r = nums.size()-1;\n      while(l <= r){\n        int mid = (l+r) >> 1;\n        if(nums[mid] >= target){\n          if(nums[mid]==target) left = mid;\n          r = mid - 1;\n        }else l = mid + 1;\n      }\n      l = 0, r = nums.size()-1;\n      while(l <= r){\n        int mid = (l+r) >> 1;\n        if(nums[mid] <= target){\n          if(nums[mid] == target) right = mid;\n          l = mid + 1;\n        }else r = mid - 1;\n      }\n      vector<int> ans = {left, right};\n      return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1650,
            "frontend_question_id": "34",
            "question_id": 34,
            "title": "在排序数组中查找元素的第一个和最后一个位置",
            "content": "<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>\n\n<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 8\n<strong>输出：</strong>[3,4]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 6\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [], target = 0\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> 是一个非递减数组</li>\n\t<li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "find-first-and-last-position-of-element-in-sorted-array",
            "expand": false
        }
    },
    {
        "leetcode": 1651,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1;\n        bool isFormer = target >= nums[0];\n        while(l <= r){\n            int mid = (l + r) >> 1;\n            if(nums[mid] == target) return mid;\n            else if(nums[mid] > target){\n                // target mid | --- \n                if(isFormer){\n                    r = mid - 1;\n                }else{\n                    // mid | target \n                    if(nums[mid] >= nums[0]) l = mid + 1;\n                    // --- | target mid \n                    else r = mid - 1;\n                }\n            }else{\n\n                \n                if(isFormer){\n                    // mid target |  ----\n                    if(nums[mid] >= nums[0]) l = mid + 1;\n                    // target | mid\n                    else r = mid - 1;\n                }else{\n                    // | mid target\n                   l = mid + 1;  \n                }\n            }\n        }\n        return -1;\n    }\n\n};\n```",
        "leetcodeInfo": {
            "id": 1651,
            "frontend_question_id": "33",
            "question_id": 33,
            "title": "搜索旋转排序数组",
            "content": "<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>\n\n<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 <= k < nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>\n\n<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 0\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 3\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 0\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5000</code></li>\n\t<li><code>-10^4 <= nums[i] <= 10^4</code></li>\n\t<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>\n\t<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>\n\t<li><code>-10^4 <= target <= 10^4</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p>\n",
            "level": 2,
            "slug_title": "search-in-rotated-sorted-array",
            "expand": false
        }
    },
    {
        "leetcode": 1652,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> st;\n        int n = s.size();\n        for(int i = 0; i < n; i++){\n            if(s[i] == '(') st.push(i);\n            else{\n                if(st.empty()) s[i] = '0';\n                else st.pop();\n            } \n        }\n        while(not st.empty()){\n            s[st.top()] = '0';\n            st.pop();\n        }\n\n        int ans = 0, i = 0, j = 0;\n        while(j < n){\n            i = j;\n            while(i < n and s[i] == '0') i++;\n            j = i;\n            while(j < n and s[j] != '0') j++;\n            // cout << j << i << endl;\n            ans = max(ans, j - i);\n        }\n        // cout << s << endl;\n        return ans;\n\n    }\n};\n```\n\n\n```\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int m = s.size();\n        stack<pair<char,int>> st;\n        // st.push(-1);\n        int ans = 0;\n        for(int i = 0; i < m; i++){\n            if(s[i] == ')'){\n                if(st.empty() or st.top().first == ')') st.push({')', i});\n                else{\n                    auto top = st.top(); \n                    if(top.first == '('){\n                       st.pop();    \n                       if(st.empty()) ans = max(ans, i + 1);\n                       else ans = max(ans, i - st.top().second);\n                    } \n                    // st.pop();\n                }\n            }else{\n                st.push({'(', i});\n            }\n        }\n        return ans;\n    }\n};\n\n```",
        "leetcodeInfo": {
            "id": 1652,
            "frontend_question_id": "32",
            "question_id": 32,
            "title": "最长有效括号",
            "content": "<p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>\n\n<p> </p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(()\"\n<strong>输出：</strong>2\n<strong>解释：</strong>最长有效括号子串是 \"()\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \")()())\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长有效括号子串是 \"()()\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"\"\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>\n</ul>\n</div>\n</div>\n",
            "level": 3,
            "slug_title": "longest-valid-parentheses",
            "expand": false
        }
    },
    {
        "leetcode": 1659,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n      ListNode* fake = new ListNode(-1, head), *lstart = fake, *start = fake, *end, *rend;\n      int cnt = 0;\n      while(true){\n        cnt = 0;\n        end = lstart;\n        start = lstart->next;\n        while(cnt < k and end->next) end = end->next, cnt++; //找到end\n        rend = end->next; //end下一个\n        if(cnt == k){   //如果满足k\n          end->next = nullptr;  //断开尾节点\n          lstart->next = reverse(lstart->next); //前前节点\n          start->next = rend; //尾部节点\n        }else break;\n        lstart = start;\n      }\n      return fake->next;\n    }\n    ListNode* reverse(ListNode* head){\n      ListNode* pre = nullptr, *cur = head, *last;\n      while(cur){\n        last = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = last;\n      }\n      return pre;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1659,
            "frontend_question_id": "25",
            "question_id": 25,
            "title": "K 个一组翻转链表",
            "content": "<p>给你一个链表，每 <em>k </em>个节点一组进行翻转，请你返回翻转后的链表。</p>\n\n<p><em>k </em>是一个正整数，它的值小于或等于链表的长度。</p>\n\n<p>如果节点总数不是 <em>k </em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>\n\t<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[2,1,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 3\n<strong>输出：</strong>[3,2,1,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 1\n<strong>输出：</strong>[1,2,3,4,5]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], k = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<ul>\n</ul>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>列表中节点的数量在范围 <code>sz</code> 内</li>\n\t<li><code>1 <= sz <= 5000</code></li>\n\t<li><code>0 <= Node.val <= 1000</code></li>\n\t<li><code>1 <= k <= sz</code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "reverse-nodes-in-k-group",
            "expand": false
        }
    },
    {
        "leetcode": 1661,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\n// 归并排序\nclass Solution {\npublic:\n   ListNode* mergeListNode(ListNode* r1, ListNode* r2){\n        if(not (r1 and r2)){\n            return r1 ? r1 : r2;\n        }\n        ListNode* fake = new ListNode(), *cur  = fake, *c1 = r1, *c2 = r2;\n        while(c1 and c2){\n            if(c1->val > c2->val){\n                cur->next = c2;\n                c2=c2->next;\n            }else{\n                cur->next = c1;\n                c1 = c1->next;\n            }\n            cur=cur->next;\n        }\n        cur->next = (c1 ? c1 : c2);\n        return fake->next;\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        int len = lists.size();\n        if(len == 0) return nullptr;\n        for(int step = 1; step < len; step <<= 1){\n            for(int start = step; start < len; start += (step << 1)){\n                lists[start-step] = mergeListNode(lists[start-step], lists[start]);\n            }\n        }\n        return lists[0];\n    }\n};\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n \n // 最小堆\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>> pq;\n        ListNode* fakeHead = new ListNode(-1), *cur = fakeHead;\n        for(int i = 0; i < (int)lists.size(); i++){\n            ListNode* cur = lists[i];\n            if(cur) pq.push({-1 * cur->val, cur});\n        }\n        while(not pq.empty()){\n            ListNode* minValNode = pq.top().second; pq.pop();\n            cur->next = minValNode;\n            if(minValNode->next) pq.push({-1 * minValNode->next->val, minValNode->next});\n            cur = cur->next;\n        }\n        return fakeHead->next;\n    }\n};\n\n```",
        "leetcodeInfo": {
            "id": 1661,
            "frontend_question_id": "23",
            "question_id": 23,
            "title": "合并K个排序链表",
            "content": "<p>给你一个链表数组，每个链表都已经按升序排列。</p>\n\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>输出：</strong>[1,1,2,3,4,4,5,6]\n<strong>解释：</strong>链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>lists = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[]]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n\t<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n",
            "level": 3,
            "slug_title": "merge-k-sorted-lists",
            "expand": false
        }
    },
    {
        "leetcode": 1662,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\nclass Solution {\n    void backtrack(vector<string>& ans, string& cur, int open, int close, int n) {\n        if (cur.size() == n * 2) {\n            ans.push_back(cur);\n            return;\n        }\n        if (open < n) {\n            cur.push_back('(');\n            backtrack(ans, cur, open + 1, close, n);\n            cur.pop_back();\n        }\n        if (close < open) {\n            cur.push_back(')');\n            backtrack(ans, cur, open, close + 1, n);\n            cur.pop_back();\n        }\n    }\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> result;\n        string current;\n        backtrack(result, current, 0, 0, n);\n        return result;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1662,
            "frontend_question_id": "22",
            "question_id": 22,
            "title": "括号生成",
            "content": "<p>数字 <code>n</code>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[\"()\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "generate-parentheses",
            "expand": false
        }
    },
    {
        "leetcode": 1669,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n      sort(nums.begin(), nums.end());\n      vector<vector<int>> ans;\n      if(nums.size() < 3) return ans;\n      for(int i = 0; i < nums.size()-2; i++){\n        if(i and nums[i] == nums[i-1]) continue;\n        int mid = nums[i], target = -1 * nums[i];\n        int l = i+1, r = nums.size()-1;\n        while(l < r){\n          int cur = nums[l] + nums[r];\n          if(cur == target) {\n          //去重操作注意\n            if(not ans.size() or nums[i] != ans.back()[0] or nums[l] != ans.back()[1]) ans.push_back({mid, nums[l], nums[r]});\n            l++;\n          }\n          else if(cur > target) r--;\n          else l++;\n        }\n      }\n      return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1669,
            "frontend_question_id": "15",
            "question_id": 15,
            "title": "三数之和",
            "content": "<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c = </em>0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>\n\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 3000</code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
            "level": 2,
            "slug_title": "3sum",
            "expand": false
        }
    },
    {
        "leetcode": 1676,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int idx = 0, sign = 1;\n        int n = s.size();\n        // 处理无用空格\n        while(idx < n and s[idx] == ' ') idx++;\n        \n        // 处理符号\n        if(idx < n and (s[idx] == '-' or s[idx] == '+')){\n            sign = (s[idx] == '-') ? -1 : 1;\n            idx++;\n        }\n        \n        int res = 0;\n        // 处理数字\n        while(idx < n and isdigit(s[idx])){\n            int digit = s[idx] - '0';\n            // core code\n            if(res > (INT_MAX - digit) / 10) return sign == 1 ? INT_MAX : INT_MIN;\n            res = res * 10 + digit;\n            ++idx;\n        }\n        return res * sign;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1676,
            "frontend_question_id": "8",
            "question_id": 8,
            "title": "字符串转换整数 (atoi)",
            "content": "<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>\n\n<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>\n\n<ul>\n\t<li>读入字符串并丢弃无用的前导空格</li>\n\t<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>\n\t<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>\n\t<li>将前面步骤读入的这些数字转换为整数（即，\"123\" -> 123， \"0032\" -> 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>\n\t<li>如果整数数超过 32 位有符号整数范围 <code>[−2<sup>31</sup>,  2<sup>31 </sup>− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2<sup>31</sup></code> 的整数应该被固定为 <code>−2<sup>31</sup></code> ，大于 <code>2<sup>31 </sup>− 1</code> 的整数应该被固定为 <code>2<sup>31 </sup>− 1</code> 。</li>\n\t<li>返回整数作为最终结果。</li>\n</ul>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>\n\t<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"42\"\n<strong>输出：</strong>42\n<strong>解释：</strong>加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"<strong>42</strong>\"（读入 \"42\"）\n           ^\n解析得到整数 42 。\n由于 \"42\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 42 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"   -42\"\n<strong>输出：</strong>-42\n<strong>解释：</strong>\n第 1 步：\"<strong>   </strong>-42\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   <strong>-</strong>42\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   -<strong>42</strong>\"（读入 \"42\"）\n               ^\n解析得到整数 -42 。\n由于 \"-42\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 -42 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"4193 with words\"\n<strong>输出：</strong>4193\n<strong>解释：</strong>\n第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"<strong>4193</strong> with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 \"4193\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 4193 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"words and 987\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n第 1 步：\"words and 987\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"words and 987\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"words and 987\"（由于当前字符 'w' 不是一个数字，所以读入停止）\n         ^\n解析得到整数 0 ，因为没有读入任何数字。\n由于 0 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 0 。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"-91283472332\"\n<strong>输出：</strong>-2147483648\n<strong>解释：</strong>\n第 1 步：\"-91283472332\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"<strong>-</strong>91283472332\"（读入 '-' 字符，所以结果应该是负数）\n          ^\n第 3 步：\"-<strong>91283472332</strong>\"（读入 \"91283472332\"）\n                     ^\n解析得到整数 -91283472332 。\n由于 -91283472332 小于范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 的下界，最终结果被截断为 -2<sup>31</sup> = -2147483648 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 200</code></li>\n\t<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>\n</ul>\n",
            "level": 2,
            "slug_title": "string-to-integer-atoi",
            "expand": false
        }
    },
    {
        "leetcode": 1677,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n期间需要满足INT_MIN/10 <= rev <= INT_MAX/10\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int ans = 0;\n        // cout << INT_MIN << \" \" << INT_MAX << endl;\n        if(x == INT_MIN) return 0;\n        int sign = x > 0 ? 1 : -1;\n        x = abs(x);\n        while(x){\n            int curbit = x % 10;\n            // ans * 10 + curbit >= INT_MIN ==> ans >= (INT_MIN - curbit) / 10\n            if(ans > (INT_MAX - curbit) / 10) return 0;\n            else ans = ans * 10 + curbit;\n            x /= 10;\n        }\n        return sign * ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1677,
            "frontend_question_id": "7",
            "question_id": 7,
            "title": "整数反转",
            "content": "<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>\n\n<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2<sup>31</sup>,  2<sup>31 </sup>− 1]</code> ，就返回 0。</p>\n<strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 123\n<strong>输出：</strong>321\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = -123\n<strong>输出：</strong>-321\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 120\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 0\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> <= x <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
            "level": 1,
            "slug_title": "reverse-integer",
            "expand": false
        }
    },
    {
        "leetcode": 1680,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在 CodeTop 微信小程序中查看)\n\n```\ntime: O(logk)\nspace: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size();\n        int n = nums2.size();\n        int left = (m + n + 1) /2, right = (m + n + 2) / 2;\n        return (getKth(nums1, 0, m-1, nums2, 0, n-1, left) + getKth(nums1, 0, m-1, nums2, 0, n-1, right)) / 2.0;\n    }\n\n    int getKth(vector<int>& nums1, int start1, int end1, vector<int>& nums2, int start2, int end2, int k){\n\n        int len1 = end1 - start1 + 1, len2 = end2 - start2 + 1;\n        \n        // make the shorter vector as nums1\n        if(len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);\n        if(len1 == 0) return nums2[start2 + k - 1];\n\n        if(k == 1)  return min(nums1[start1], nums2[start2]);\n\n        int i = start1 + min(len1, k / 2) - 1;\n        int j = start2 + min(len2, k / 2) - 1;\n\n        if(nums1[i] > nums2[j]){\n            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));\n        }else{\n            return getKth(nums1, i + 1, end1,  nums2, start2, end2, k - (i - start1 + 1));\n        }\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1680,
            "frontend_question_id": "4",
            "question_id": 4,
            "title": "寻找两个正序数组的中位数",
            "content": "<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,3], nums2 = [2]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]\n<strong>输出：</strong>2.50000\n<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0,0], nums2 = [0,0]\n<strong>输出：</strong>0.00000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [], nums2 = [1]\n<strong>输出：</strong>1.00000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2], nums2 = []\n<strong>输出：</strong>2.00000\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 <= m <= 1000</code></li>\n\t<li><code>0 <= n <= 1000</code></li>\n\t<li><code>1 <= m + n <= 2000</code></li>\n\t<li><code>-10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p>\n",
            "level": 3,
            "slug_title": "median-of-two-sorted-arrays",
            "expand": false
        }
    },
    {
        "leetcode": 1681,
        "content": "[//]: # (支持粘贴图片啦🎉🎉🎉)\n[//]: # (保存的笔记可以在小程序中查看)\n\n```\n//滑动窗口\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n      unordered_set<int> st;\n      if(s.size() ==0)return 0;\n      int ans = 1;\n      for(int i = 0, j = 0; i < s.size(); i++){\n        while(j < i and st.count(s[i])) st.erase(s[j++]); //找到第一个满足情况的\n        st.insert(s[i]);\n        ans = max(i - j + 1, ans);\n      }\n      return ans;\n    }\n};\n```",
        "leetcodeInfo": {
            "id": 1681,
            "frontend_question_id": "3",
            "question_id": 3,
            "title": "无重复字符的最长子串",
            "content": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串 </strong>的长度。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"abcabcbb\"\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>\"abc\"，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"bbbbb\"\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"b\"</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"pwwkew\"\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"wke\"</code>，所以其长度为 3。\n     请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>\"pwke\"</code> 是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"\"\n<strong>输出: </strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由英文字母、数字、符号和空格组成</li>\n</ul>\n",
            "level": 2,
            "slug_title": "longest-substring-without-repeating-characters",
            "expand": false
        }
    }
]